{"meta":{"title":"emitor's blog","subtitle":null,"description":null,"author":"Emitor","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JMockit","slug":"JMockit","date":"2019-03-18T15:20:02.000Z","updated":"2019-03-18T15:53:39.745Z","comments":true,"path":"2019/03/18/JMockit/","link":"","permalink":"http://yoursite.com/2019/03/18/JMockit/","excerpt":"","text":"maven依赖：123456&lt;dependency&gt; &lt;groupId&gt;org.jmockit&lt;/groupId&gt; &lt;artifactId&gt;jmockit&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 这里的依赖是成对的并且有先后顺序耦合 @Mocked当@Mocked修饰一个具体类时，会mock该具体类所有成员属性，若是基本类型，返回原始0，若是String则返回null，若是其他依赖的引用类型，则继续mock它使其不为空引用，但递归地，其内部的对象引用任然像上面那样继续递归mock。 123456789101112131415161718192021222324252627282930313233343536373839404142 //@Mocked注解用途public class MockedClassTest &#123; // 加上了JMockit的API @Mocked, JMockit会帮我们实例化这个对象，不用担心它为null @Mocked Locale locale; // 当@Mocked作用于class @Test public void testMockedClass() &#123; // 静态方法不起作用了,返回了null Assert.assertTrue(Locale.getDefault() == null); // 非静态方法（返回类型为String）也不起作用了，返回了null Assert.assertTrue(locale.getCountry() == null); // 自已new一个，也同样如此，方法都被mock了 Locale chinaLocale = new Locale(\"zh\", \"CN\"); Assert.assertTrue(chinaLocale.getCountry() == null); &#125; &#125;~~~ ~~~java//@Mocked注解用途public class MockedInterfaceTest &#123; // 加上了JMockit的API @Mocked, JMockit会帮我们实例化这个对象，尽管这个对象的类型是一个接口，不用担心它为null @Mocked HttpSession session; // 当@Mocked作用于interface @Test public void testMockedInterface() &#123; // （返回类型为String）也不起作用了，返回了null Assert.assertTrue(session.getId() == null); // （返回类型为原始类型）也不起作用了，返回了0 Assert.assertTrue(session.getCreationTime() == 0L); // (返回类型为原非始类型，非String，返回的对象不为空，这个对象也是JMockit帮你实例化的，同样这个实例化的对象也是一个Mocked对象) Assert.assertTrue(session.getServletContext() != null); // Mocked对象返回的Mocked对象，（返回类型为String）的方法也不起作用了，返回了null Assert.assertTrue(session.getServletContext().getContextPath() == null); &#125;&#125; @Injected @Tested@Mocked对mock的类所有实例进行mock。在特定场景下，只需要对依赖的实例进行mock，搭配使用@Injected @Tested来实现这种功能: 简单demo演示@Injected @Mocked区别1234567891011121314public class TestJMockitTest &#123; @Injectable private TestJMockit testJMockit; @Test public void printStringInConsole() &#123; System.out.println(\"start ========\"); new TestJMockit().printStringInConsole(); // 会打印 System.out.println(\"end ========\"); &#125;&#125; 1234567891011121314public class TestJMockitTest &#123; @Mocked private TestJMockit testJMockit; @Test public void printStringInConsole() &#123; System.out.println(\"start ========\"); new TestJMockit().printStringInConsole(); // 不会打印 System.out.println(\"end ========\"); &#125;&#125; 123456public class TestJMockit &#123; public void printStringInConsole() &#123; System.out.println(\"Im Stephen Curry 3 Points!!!\"); &#125;&#125; 可见@Mocked针对类型mock，@Injected针对类实例mock @Capturing@Capturing 意为捕捉，JMockit中，当知道基类或者接口时，想要控制其所有子类的实现，则使用@Capturing，就像 “捕捉” 本身的意义一样。 12345678public interface BasketballPlayer &#123; /** * 篮球运动员得分技能 */ int getScore(String name);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940@SpringBootTest@RunWith(SpringRunner.class)public class BasketballPlayerTest &#123; private BasketballPlayer basketballPlayer1 = name -&gt; &#123; if (name.equals(\"Kobe\")) &#123; return 81; &#125; return 0; &#125;; private BasketballPlayer wonderfulGiftPlayer = (BasketballPlayer) Proxy.newProxyInstance(BasketballPlayer.class.getClassLoader(), new Class[]&#123;BasketballPlayer.class&#125;, (proxy, method, args) -&gt; &#123; if (args[0].equals(\"Kobe\")) &#123; return 81; &#125; return 0; &#125;); // 上面是JDK动态代理生成的BasketballPlayer实例 // 如果是科比则得分81 @Test public void getScore(@Capturing BasketballPlayer basketballPlayer) &#123; // @Capturing 会捕捉BasketballPlayer所有实例，即使是运行时生成的动态实例。 new Expectations() &#123; &#123; basketballPlayer.getScore(anyString); result = 81; &#125; &#125;; Assert.assertEquals(81, basketballPlayer1.getScore(\"couldBeAnyString\"));// Assert.assertEquals(81, wonderfulGiftPlayer.getScore(\"couldBeAnyString\")); // 不能测试成功，JDK动态代理 &#125;&#125; 上面的JDK动态代理的mock失败了，但是文档上貌似显示是支持的，暂未找到原因…可见，@Mocked 和 @Capturing 的区别，前者mock不能影响子类和实现类。因此，在一些第三方API需要mock时，就使用@Capturing去捕捉这种关系，但是其实若是单一的第三方接口，直接@Mocked出一个匿名内部类也可以实现，@Capturing可以运用于一些比较特定的场合，到时候找不到解决方式时就会想到还有一个@Capturing，一般情况下，是不怎么使用到@Capturing的。 mockup 和 @mock的搭配使用不建议使用此方式，因为这种方式是new一个匿名内部类，在其中对想要mock的方法一个一个添加@Mock去mock，看似增加了定制化，但是实际上每个需要被mock的方法都要手动实现一遍：一是不够优雅，二是比如mock一个HTTPSession这种，需要大量的@Mock手动实现，而此时@Mocked一行就可以解决。功能只需要在expection中去record即可。 Expectations所谓的 record-replay （录制-回放）功能，在此种方式下，可录制所有想要被mock的方法和它的返回值，代码比较优雅。需要注意的是在new expectations内部中录制过程中，要再手动添加一对大括号{}。 1234567new Expectations() &#123; // 需要用一对大括包住录制过程 &#123; basketballPlayer.getScore(anyString); result = 81; &#125; &#125;; @Verification12345678910111213141516171819new Verifications() &#123; // 这是一个Verifications匿名内部类 &#123; // 这个是内部类的初始化代码块，我们在这里写验证脚本，脚本的格式要遵循下面的约定 //方法调用(可是类的静态方法调用，也可以是对象的非静态方法调用) //times/minTimes/maxTimes 表示调用次数的限定要求。赋值要紧跟在方法调用后面，也可以不写（表示只要调用过就行，不限次数） //...其它准备验证脚本的代码 //方法调用 //times/minTimes/maxTimes 赋值 &#125;&#125;; 还可以再写new一个Verifications，只要出现在重放阶段之后均有效。new Verifications() &#123; &#123; //...验证脚本 &#125;&#125;; 整个验证过程大致分为{录制}回放验证这里的@Verification就是用来验证，比如一个方法调用几次，或者是调用次数的上下限，都可以检验。不满足即抛出错误。使用较少。 以上，大概就是JMockit使用基础。 零配置启动mock123456789101112131415161718192021222324252627282930313233343536373839404142package cn.emitor.spring4d.utils;import mockit.Expectations;import mockit.Injectable;import mockit.Tested;import org.junit.Assert;import org.junit.Test;/** * @author Emitor * on 2018/12/26. */public class MyJMockitTestWorkTest &#123; @Injectable MyMockItDependencyObject dependencyObject; @Tested MyJMockitTestWork work; @Test public void sdOutPrint() &#123; new Expectations()&#123; &#123; dependencyObject.getMySayHelloANumber(); result = 1; &#125; &#125;; Assert.assertEquals(\"oh it's not my expectation~\", work.sdOutPrint(1), dependencyObject.getMySayHelloANumber()); new Expectations() &#123; &#123; dependencyObject.getMyA(); result = 1; &#125; &#125;; Assert.assertEquals(\"oh, it's not my expectation!\", work.sdOutPrint(1), dependencyObject.getMyA()); &#125;&#125; 依赖的两个类：12345public class MyJMockitTestWork &#123; public Integer sdOutPrint(Integer a) &#123; return a; &#125;&#125; 12345678910111213141516171819202122232425@Componentpublic class MyMockItDependencyObject &#123; public final void a() &#123; &#125; public static void b() &#123; &#125; public static final String e = \"1\"; private static void c() &#123; &#125; private Integer a = 1; public Integer getMySayHelloANumber() &#123; return new Random().nextInt(10); &#125; public Integer getMyA() &#123; return a; &#125;&#125; 就可以实现 record-replay 功能的测试，解决功能依赖性问题。 简单注解配置实现拥有Spring上下文的测试环境12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class CanIBeAutowiredssTest &#123; @Autowired private CanIBeAutowired canIBeAutowired; @Autowired DoShitController doShitController; @Test public void getAString() &#123; String xMas = canIBeAutowired.getAString(); Assert.assertNotNull(&quot;oh, no xMas&quot;, xMas); Assert.assertEquals(xMas, &quot;merry Xmas&quot;); Assert.assertEquals(doShitController.doShitLikeAlways(&quot;&quot;), &quot;doShitLikeAlwaysBe: &quot;); &#125;&#125; 上面即实现了自动注入，即这里已经出现Spring上下文。其中， @RunWith(SpringRunner.class) 和 @SpringBootTest 缺一不可。前者缺失导致无法注入值，即@AutoWired下面的为null。而缺失后者导致bean无法创建错误。 简单配置实现controller测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.emitor.spring4d.controllers;import mockit.Injectable;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.ResultActions;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import static org.junit.Assert.assertEquals;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;/** * @author Emitor * on 2018/12/26. */@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfigurationpublic class DoControllerTest &#123; @Autowired protected WebApplicationContext wac; @Injectable MockMvc mockMvc; @Before() //这个方法在每个方法执行之前都会执行一遍 public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 &#125; @Test public void doLikeAlways() throws Exception &#123; assertEquals(1, 1, 1); ResultActions resultActions = mockMvc.perform(get(\"/shit\").param(\"ApiName\", \"this is a api name\")); String returnString = resultActions.andExpect(status().isOk()) .andDo(print()) .andReturn().getResponse().getContentAsString(); System.out.println(returnString); &#125;&#125; 这里产生spring运行content以便mock出想要的网络请求和自动注入效果。","categories":[],"tags":[{"name":"JMockIt","slug":"JMockIt","permalink":"http://yoursite.com/tags/JMockIt/"}]}]}